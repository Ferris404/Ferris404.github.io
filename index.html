<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Split images into color layers with advanced controls for color extraction and processing">
    <meta name="theme-color" content="#1a1a1a">
    <title>Color Splitter - Image Color Layer Extraction Tool</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-bg: #1a1a1a;
            --secondary-bg: #2c2c2c;
            --tertiary-bg: #3c3c3c;
            --border-color: #4d4d4d;
            --primary-text: #e0e0e0;
            --secondary-text: #a0a0a0;
            --accent-color: #60a5fa;
            --accent-hover: #3b82f6;
            --accent-active: #2563eb;
            --shadow-color: rgba(0, 0, 0, 0.4);
            --accent-shadow: rgba(59, 130, 246, 0.5);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Poppins', system-ui, -apple-system, sans-serif;
            background: linear-gradient(135deg, var(--primary-bg), var(--secondary-bg));
            margin: 0;
            padding: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            color: var(--primary-text);
            line-height: 1.6;
        }

        .container {
            background: var(--secondary-bg);
            border-radius: 16px;
            box-shadow: 0 8px 24px var(--shadow-color);
            padding: 30px;
            width: 100%;
            max-width: 1200px;
            text-align: center;
            animation: fadeIn 0.5s ease-in;
            border: 1px solid var(--border-color);
        }

        @keyframes fadeIn {
            from { 
                opacity: 0; 
                transform: translateY(-20px); 
                filter: blur(10px);
            }
            to { 
                opacity: 1; 
                transform: translateY(0);
                filter: blur(0);
            }
        }

        h1 {
            color: var(--accent-color);
            margin-bottom: 10px;
            font-size: clamp(1.8em, 4vw, 2.2em);
            font-weight: 700;
            letter-spacing: 1px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .subtitle {
            color: var(--secondary-text);
            margin-bottom: 30px;
            font-size: clamp(0.9em, 2vw, 1em);
            font-weight: 300;
        }

        h3 {
            color: var(--primary-text);
            margin-bottom: 15px;
            font-size: 1.4em;
            font-weight: 600;
        }

        .input-group {
            margin-bottom: 20px;
            text-align: left;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: var(--primary-text);
            font-weight: 500;
            font-size: 0.95em;
        }

        input[type="file"],
        input[type="number"],
        input[type="range"] {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-sizing: border-box;
            font-size: 0.9em;
            background: var(--tertiary-bg);
            color: var(--primary-text);
            transition: all 0.3s ease;
        }

        input[type="file"]:hover,
        input[type="number"]:hover,
        input[type="range"]:hover {
            border-color: var(--accent-color);
            box-shadow: 0 0 0 2px rgba(96, 165, 250, 0.2);
        }

        input[type="file"]:focus,
        input[type="number"]:focus,
        input[type="range"]:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 3px rgba(96, 165, 250, 0.3);
        }

        input[type="file"]::-webkit-file-upload-button {
            background: linear-gradient(135deg, var(--accent-color), var(--accent-hover));
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        input[type="file"]::-webkit-file-upload-button:hover {
            background: linear-gradient(135deg, var(--accent-hover), var(--accent-active));
            transform: translateY(-1px);
        }

        input[type="range"] {
            height: 6px;
            padding: 0;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--accent-color);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            background: var(--accent-hover);
        }

        input[type="range"] + span {
            display: inline-block;
            margin-left: 10px;
            font-size: 0.9em;
            color: var(--secondary-text);
            min-width: 30px;
        }

        button {
            background: linear-gradient(135deg, var(--accent-color), var(--accent-hover));
            color: white;
            padding: 12px 28px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        button:hover {
            background: linear-gradient(135deg, var(--accent-hover), var(--accent-active));
            transform: translateY(-3px);
            box-shadow: 0 4px 12px var(--accent-shadow);
        }

        button:active {
            transform: translateY(-1px);
        }

        button:disabled {
            background: var(--border-color);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
            opacity: 0.7;
        }

        button::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 5px;
            height: 5px;
            background: rgba(255, 255, 255, 0.5);
            opacity: 0;
            border-radius: 100%;
            transform: scale(1, 1) translate(-50%);
            transform-origin: 50% 50%;
        }

        button:focus:not(:active)::after {
            animation: ripple 1s ease-out;
        }

        @keyframes ripple {
            0% {
                transform: scale(0, 0);
                opacity: 0.5;
            }
            100% {
                transform: scale(100, 100);
                opacity: 0;
            }
        }

        #imageComparison {
            margin-top: 30px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 30px;
            justify-content: center;
        }

        .image-container {
            background: var(--tertiary-bg);
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 1px solid var(--border-color);
        }

        .image-container:hover {
            transform: scale(1.02);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
        }

        .image-container img {
            max-width: 100%;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            transition: all 0.3s ease;
        }

        .image-container img:hover {
            border-color: var(--accent-color);
        }

        .image-container p {
            margin-top: 10px;
            font-size: 1em;
            color: var(--primary-text);
            font-weight: 500;
        }

        #progress {
            margin-top: 20px;
            font-size: 0.9em;
            color: var(--secondary-text);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            min-height: 24px;
        }

        #progress.loading::before {
            content: '';
            width: 20px;
            height: 20px;
            border: 2px solid var(--accent-color);
            border-top: 2px solid transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        #downloadSection {
            margin-top: 20px;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.5s ease;
        }

        #downloadSection.visible {
            opacity: 1;
            transform: translateY(0);
        }

        canvas {
            display: none;
        }

        .tooltip {
            position: relative;
            display: inline-flex;
            align-items: center;
            cursor: help;
            margin-left: 5px;
            color: var(--secondary-text);
        }

        .tooltip::before {
            content: '?';
            display: flex;
            align-items: center;
            justify-content: center;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            border: 1px solid currentColor;
            font-size: 12px;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 220px;
            background: var(--primary-bg);
            color: var(--primary-text);
            text-align: center;
            padding: 10px;
            border-radius: 6px;
            position: absolute;
            z-index: 1;
            bottom: 130%;
            left: 50%;
            margin-left: -110px;
            opacity: 0;
            transition: all 0.3s ease;
            font-size: 0.85em;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            border: 1px solid var(--border-color);
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
            transform: translateY(-5px);
        }

        .settings-group {
            background: var(--tertiary-bg);
            padding: 25px;
            border-radius: 12px;
            margin-bottom: 20px;
            border: 1px solid var(--border-color);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            margin-top: 10px;
            gap: 12px;
        }

        .checkbox-group input[type="checkbox"] {
            width: 20px;
            height: 20px;
            accent-color: var(--accent-color);
            cursor: pointer;
        }

        @media (max-width: 768px) {
            body {
                padding: 15px;
            }

            .container {
                padding: 20px;
            }

            .settings-group {
                padding: 15px;
            }

            button {
                width: 100%;
            }
        }

        @media (prefers-reduced-motion: reduce) {
            * {
                animation: none !important;
                transition: none !important;
            }
        }

        @media (prefers-color-scheme: light) {
            :root {
                --primary-bg: #f5f5f5;
                --secondary-bg: #ffffff;
                --tertiary-bg: #f0f0f0;
                --border-color: #e0e0e0;
                --primary-text: #333333;
                --secondary-text: #666666;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Color Splitter</h1>
        <p class="subtitle">Split your images into color layers effortlessly.</p>

        <div class="input-group">
            <label for="imageInput">Upload Your Image:</label>
            <input type="file" id="imageInput" accept="image/*">
        </div>

        <div class="settings-group">
            <h3>Settings</h3>
            <div class="input-group">
                <label for="numColors">Colors to Extract <span class="tooltip"><span class="tooltiptext">Number of unique colors to extract from the image.</span></span></label>
                <input type="number" id="numColors" value="16" min="1" max="1000">
            </div>
            <div class="input-group">
                <label for="minRegionSize">Remove Stray Pixels <span class="tooltip"><span class="tooltiptext">Minimum pixel group size to keep; smaller regions are removed.</span></span></label>
                <input type="range" id="minRegionSize" min="0" max="100" value="0" step="1">
                <span id="minRegionValue">0</span>
            </div>
            <div class="input-group">
                <label for="colorSimilarityThreshold">Merge Similar Colors <span class="tooltip"><span class="tooltiptext">Threshold for merging similar colors; higher values group more shades.</span></span></label>
                <input type="range" id="colorSimilarityThreshold" min="0" max="100" value="15" step="1">
                <span id="colorSimilarityValue">15</span>
            </div>
            <div class="input-group">
                <label for="outputSize">Output Size <span class="tooltip"><span class="tooltiptext">Output image dimensions in pixels.</span></span></label>
                <input type="number" id="outputSize" value="702" min="1" max="2000">
            </div>
            <div class="input-group checkbox-group">
                <input type="checkbox" id="stretchImage" checked>
                <label for="stretchImage">Stretch Image <span class="tooltip"><span class="tooltiptext">Stretch to fit output size; uncheck to crop instead.</span></span></label>
            </div>
        </div>

        <button id="processBtn" onclick="processImage()">Split Colors Now</button>
        <div id="progress"></div>
        <div id="imageComparison">
            <div class="image-container">
                <img id="originalImg" src="" alt="Original Image" style="display: none;">
                <p>Original Image</p>
            </div>
            <div class="image-container">
                <img id="previewImg" src="" alt="Processed Image" style="display: none;">
                <p>Processed Image</p>
            </div>
        </div>
        <div id="downloadSection"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script>
        // Helper function to get elements by ID
        const $ = (id) => document.getElementById(id);

        // Simple seeded PRNG (Mulberry32) for consistent results
        function seededRandom(seed) {
            let t = seed += 0x6D2B79F5;
            t = Math.imul(t ^ t >>> 15, t | 1);
            t ^= t + Math.imul(t ^ t >>> 7, t | 61);
            return ((t ^ t >>> 14) >>> 0) / 4294967296;
        }

        // Seed for consistency
        let seed = 123456789;

        // Input event listeners for real-time updates
        $('minRegionSize').addEventListener('input', () => $('minRegionValue').textContent = $('minRegionSize').value);
        $('colorSimilarityThreshold').addEventListener('input', () => $('colorSimilarityValue').textContent = $('colorSimilarityThreshold').value);

        // Handle image upload and preview
        $('imageInput').addEventListener('change', () => {
            const fileInput = $('imageInput');
            const originalImg = $('originalImg');
            
            if (fileInput.files && fileInput.files[0]) {
                const file = fileInput.files[0];
                
                // Validate file type
                if (!file.type.startsWith('image/')) {
                    alert('Please upload an image file.');
                    fileInput.value = '';
                    return;
                }

                // Create object URL and update preview
                const objectUrl = URL.createObjectURL(file);
                originalImg.src = objectUrl;
                originalImg.style.display = 'block';
                
                // Reset UI elements
                $('previewImg').style.display = 'none';
                $('downloadSection').innerHTML = '';
                $('progress').innerHTML = '';
                $('downloadSection').classList.remove('visible');
                
                // Clean up object URL when image loads
                originalImg.onload = () => URL.revokeObjectURL(objectUrl);
            } else {
                originalImg.style.display = 'none';
            }
        });

        // Calculate Euclidean distance between colors
        function distance(a, b) {
            return Math.sqrt((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2 + (a[2] - b[2]) ** 2);
        }

        // K-means++ initialization
        function kMeansPlusPlus(pixels, k) {
            const centroids = [];
            // Use seeded random for the first centroid
            centroids.push({ color: [...pixels[Math.floor(seededRandom(seed++) * pixels.length)]], count: 0 });

            // Choose remaining centroids with probability proportional to distance squared
            for (let i = 1; i < k * 1.5; i++) {
                const distances = pixels.map(p => Math.min(...centroids.map(c => distance(p, c.color))) ** 2);
                const total = distances.reduce((a, b) => a + b, 0);
                let sum = 0, rand = seededRandom(seed++) * total;
                
                for (let j = 0; j < distances.length; j++) {
                    sum += distances[j];
                    if (sum >= rand) {
                        centroids.push({ color: [...pixels[j]], count: 0 });
                        break;
                    }
                }
            }
            return centroids;
        }

        // K-means clustering algorithm
        function kMeans(pixels, k, maxIterations = 15) {
            let centroids = kMeansPlusPlus(pixels, k);
            let clusters;

            for (let iter = 0; iter < maxIterations; iter++) {
                // Assign pixels to nearest centroid
                clusters = pixels.map(pixel => {
                    let minDist = Infinity, clusterIdx = 0;
                    centroids.forEach((c, idx) => {
                        const dist = distance(pixel, c.color);
                        if (dist < minDist) {
                            minDist = dist;
                            clusterIdx = idx;
                        }
                    });
                    return clusterIdx;
                });

                // Update centroids
                const oldCentroids = centroids.map(c => ({ ...c }));
                centroids = centroids.map(() => ({ color: [0, 0, 0], count: 0 }));
                
                pixels.forEach((pixel, i) => {
                    const c = clusters[i];
                    centroids[c].color[0] += pixel[0];
                    centroids[c].color[1] += pixel[1];
                    centroids[c].color[2] += pixel[2];
                    centroids[c].count += 1;
                });

                centroids = centroids.map(c => ({
                    color: c.count ? c.color.map(v => Math.round(v / c.count)) : [0, 0, 0],
                    count: c.count
                }));

                // Check for convergence
                if (centroids.every((c, i) => distance(c.color, oldCentroids[i].color) < 1)) break;
            }

            return { centroids, clusters };
        }

        // Merge similar colors based on threshold
        function mergeSimilarColors(centroids, threshold) {
            if (!threshold) return centroids.map(c => c.color);
            
            const uniqueColors = [];
            const used = new Set();

            for (let i = 0; i < centroids.length; i++) {
                if (used.has(i)) continue;
                
                const color1 = centroids[i].color;
                let mergedColor = [...color1], mergedCount = centroids[i].count;

                for (let j = i + 1; j < centroids.length; j++) {
                    if (used.has(j)) continue;
                    
                    const color2 = centroids[j].color;
                    if (distance(color1, color2) <= threshold) {
                        mergedColor = mergedColor.map((v, k) => 
                            Math.round((v * mergedCount + color2[k] * centroids[j].count) / (mergedCount + centroids[j].count))
                        );
                        mergedCount += centroids[j].count;
                        used.add(j);
                    }
                }

                uniqueColors.push(mergedColor);
                used.add(i);
            }

            // Sort by frequency
            return uniqueColors.sort((a, b) => {
                const countA = centroids.find(c => c.color.every((v, i) => v === a[i]))?.count || 0;
                const countB = centroids.find(c => c.color.every((v, i) => v === b[i]))?.count || 0;
                return countB - countA;
            });
        }

        // Clean up small regions using flood fill
        function cleanSmallRegions(colorMap, width, height, topCentroids, minSize) {
            if (!minSize) return colorMap;
            
            const visited = new Uint8Array(width * height);
            const newColorMap = new Uint8ClampedArray(colorMap);
            
            function floodFill(x, y, targetColor, region) {
                const stack = [[x, y]];
                while (stack.length) {
                    const [cx, cy] = stack.pop();
                    const idx = (cy * width + cx) * 4;
                    
                    if (cx < 0 || cx >= width || cy < 0 || cy >= height || visited[cy * width + cx] ||
                        (colorMap[idx] !== targetColor[0] || colorMap[idx + 1] !== targetColor[1] || colorMap[idx + 2] !== targetColor[2])) {
                        continue;
                    }
                    
                    visited[cy * width + cx] = 1;
                    region.push([cx, cy]);
                    stack.push([cx + 1, cy], [cx - 1, cy], [cx, cy + 1], [cx, cy - 1]);
                }
            }

            // Process each pixel
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    if (!visited[y * width + x]) {
                        const idx = (y * width + x) * 4;
                        const color = [colorMap[idx], colorMap[idx + 1], colorMap[idx + 2]];
                        const region = [];
                        
                        floodFill(x, y, color, region);
                        
                        if (region.length < minSize) {
                            let nearestColor = topCentroids[0], minDist = Infinity;
                            
                            // Find nearest color from neighbors
                            for (const [rx, ry] of region) {
                                for (const [dx, dy] of [[1, 0], [-1, 0], [0, 1], [0, -1]]) {
                                    const nx = rx + dx, ny = ry + dy;
                                    if (nx >= 0 && nx < width && ny >= 0 && ny < height && !region.some(([px, py]) => px === nx && py === ny)) {
                                        const nIdx = (ny * width + nx) * 4;
                                        const neighborColor = [colorMap[nIdx], colorMap[nIdx + 1], colorMap[nIdx + 2]];
                                        const dist = distance(color, neighborColor);
                                        if (dist < minDist) {
                                            minDist = dist;
                                            nearestColor = neighborColor;
                                        }
                                    }
                                }
                            }
                            
                            // Replace small region with nearest color
                            for (const [rx, ry] of region) {
                                const rIdx = (ry * width + rx) * 4;
                                newColorMap[rIdx] = nearestColor[0];
                                newColorMap[rIdx + 1] = nearestColor[1];
                                newColorMap[rIdx + 2] = nearestColor[2];
                                newColorMap[rIdx + 3] = colorMap[rIdx + 3];
                            }
                        }
                    }
                }
            }
            
            return newColorMap;
        }

        // Clean up stray pixels in individual layers
        function cleanStrayPixels(layerData, width, height, minSize = 5) {
            const visited = new Uint8Array(width * height);
            const newLayerData = new Uint8ClampedArray(layerData);
            
            function floodFill(x, y, region) {
                const stack = [[x, y]];
                while (stack.length) {
                    const [cx, cy] = stack.pop();
                    const idx = (cy * width + cx) * 4;
                    
                    if (cx < 0 || cx >= width || cy < 0 || cy >= height || visited[cy * width + cx] || !layerData[idx + 3]) {
                        continue;
                    }
                    
                    visited[cy * width + cx] = 1;
                    region.push([cx, cy]);
                    stack.push([cx + 1, cy], [cx - 1, cy], [cx, cy + 1], [cx, cy - 1]);
                }
            }

            // Process each pixel
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    if (!visited[y * width + x] && layerData[(y * width + x) * 4 + 3]) {
                        const region = [];
                        floodFill(x, y, region);
                        
                        if (region.length < minSize) {
                            for (const [rx, ry] of region) {
                                newLayerData[(ry * width + rx) * 4 + 3] = 0;
                            }
                        }
                    }
                }
            }
            
            return newLayerData;
        }

        // Handle file export with fallback
        async function exportFile(blob) {
            if (window.showSaveFilePicker) {
                try {
                    const handle = await window.showSaveFilePicker({
                        suggestedName: 'color_layers.zip',
                        types: [{ description: 'ZIP File', accept: { 'application/zip': ['.zip'] } }]
                    });
                    const writable = await handle.createWritable();
                    await writable.write(blob);
                    await writable.close();
                    return;
                } catch (err) {
                    console.error('Error saving file:', err);
                }
            }
            saveAs(blob, 'color_layers.zip');
        }

        // Main processing function
        async function processImage() {
            const fileInput = $('imageInput');
            const numColors = parseInt($('numColors').value) || 1;
            const minRegionSize = parseInt($('minRegionSize').value) || 0;
            const colorSimilarityThreshold = parseInt($('colorSimilarityThreshold').value) || 0;
            const outputSize = parseInt($('outputSize').value) || 1;
            const stretchImage = $('stretchImage').checked;
            const previewImg = $('previewImg');
            const progressDiv = $('progress');
            const processBtn = $('processBtn');
            const downloadSection = $('downloadSection');

            // Reset seed for consistency
            seed = 123456789;

            // Disable UI during processing
            processBtn.disabled = true;
            progressDiv.classList.add('loading');
            progressDiv.innerHTML = 'Processing...';

            // Validate input
            if (!fileInput.files.length) {
                alert('Please upload an image!');
                processBtn.disabled = false;
                progressDiv.classList.remove('loading');
                progressDiv.innerHTML = '';
                return;
            }

            const maxColors = 1000, maxSize = 2000;
            const cappedNumColors = Math.min(numColors, maxColors);
            const cappedOutputSize = Math.min(Math.max(1, outputSize), maxSize);
            const cappedMinRegionSize = Math.min(Math.max(0, minRegionSize), maxSize);
            const cappedColorSimilarityThreshold = Math.min(Math.max(0, colorSimilarityThreshold), 100);

            if (cappedNumColors !== numColors || cappedOutputSize !== outputSize || 
                cappedMinRegionSize !== minRegionSize || cappedColorSimilarityThreshold !== colorSimilarityThreshold) {
                alert('Values capped: Colors (1-1000), Size (1-2000), Region (0-2000), Similarity (0-100).');
            }

            try {
                const img = new Image();
                img.src = URL.createObjectURL(fileInput.files[0]);
                img.onload = async () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = cappedOutputSize;
                    canvas.height = cappedOutputSize;

                    const srcWidth = img.width, srcHeight = img.height;
                    let sx, sy, sWidth, sHeight;
                    if (stretchImage) {
                        [sx, sy, sWidth, sHeight] = [0, 0, srcWidth, srcHeight];
                    } else {
                        if (srcWidth > srcHeight) {
                            [sWidth, sHeight, sx, sy] = [srcHeight, srcHeight, (srcWidth - srcHeight) / 2, 0];
                        } else {
                            [sWidth, sHeight, sx, sy] = [srcWidth, srcWidth, 0, (srcHeight - srcWidth) / 2];
                        }
                    }
                    ctx.drawImage(img, sx, sy, sWidth, sHeight, 0, 0, cappedOutputSize, cappedOutputSize);

                    const imageData = ctx.getImageData(0, 0, cappedOutputSize, cappedOutputSize);
                    const pixels = imageData.data;
                    const pixelSamples = Array.from({ length: pixels.length / 4 }, (_, i) => 
                        [pixels[i * 4], pixels[i * 4 + 1], pixels[i * 4 + 2]]
                    );

                    const { centroids, clusters } = kMeans(pixelSamples, cappedNumColors);
                    const counts = new Array(centroids.length).fill(0);
                    clusters.forEach(idx => counts[idx]++);
                    const centroidData = centroids.map((c, i) => ({ color: c.color, count: counts[i] }));
                    centroidData.sort((a, b) => b.count - a.count);

                    let uniqueCentroids = mergeSimilarColors(centroidData, cappedColorSimilarityThreshold);
                    if (uniqueCentroids.length > cappedNumColors) {
                        uniqueCentroids = uniqueCentroids.slice(0, cappedNumColors);
                    } else if (uniqueCentroids.length < cappedNumColors) {
                        uniqueCentroids = uniqueCentroids.concat(
                            centroidData.slice(uniqueCentroids.length, cappedNumColors).map(c => c.color)
                        );
                    }
                    const topCentroids = uniqueCentroids;

                    let colorMap = new Uint8ClampedArray(pixels.length);
                    const chunkSize = 10000;
                    for (let i = 0; i < pixels.length / 4; i += chunkSize) {
                        const end = Math.min(i + chunkSize, pixels.length / 4);
                        for (let j = i; j < end; j++) {
                            const pixel = pixelSamples[j];
                            const nearestColor = topCentroids.reduce((prev, curr) => 
                                distance(pixel, curr) < distance(pixel, prev) ? curr : prev
                            );
                            const offset = j * 4;
                            [colorMap[offset], colorMap[offset + 1], colorMap[offset + 2], colorMap[offset + 3]] = 
                                [...nearestColor, pixels[offset + 3]];
                        }
                    }

                    if (cappedMinRegionSize) {
                        colorMap = cleanSmallRegions(colorMap, cappedOutputSize, cappedOutputSize, topCentroids, cappedMinRegionSize);
                    }

                    ctx.putImageData(new ImageData(colorMap, cappedOutputSize, cappedOutputSize), 0, 0);
                    previewImg.src = canvas.toDataURL('image/png');
                    previewImg.style.display = 'block';

                    const zip = new JSZip();
                    topCentroids.forEach(color => {
                        const splitCanvas = document.createElement('canvas');
                        splitCanvas.width = cappedOutputSize;
                        splitCanvas.height = cappedOutputSize;
                        const splitCtx = splitCanvas.getContext('2d');
                        const splitData = splitCtx.createImageData(cappedOutputSize, cappedOutputSize);

                        for (let i = 0; i < colorMap.length; i += 4) {
                            if (colorMap[i] === color[0] && colorMap[i + 1] === color[1] && colorMap[i + 2] === color[2]) {
                                splitData.data.set(colorMap.slice(i, i + 4), i);
                            } else {
                                splitData.data[i + 3] = 0;
                            }
                        }

                        const cleanedData = cleanStrayPixels(splitData.data, cappedOutputSize, cappedOutputSize);
                        splitCtx.putImageData(new ImageData(cleanedData, cappedOutputSize, cappedOutputSize), 0, 0);
                        zip.file(`${color.map(v => v.toString(16).padStart(2, '0')).join('')}.png`, 
                            splitCanvas.toDataURL('image/png').split(',')[1], { base64: true });
                    });

                    const zipBlob = await zip.generateAsync({ type: 'blob' });
                    downloadSection.innerHTML = '';
                    const downloadBtn = document.createElement('button');
                    downloadBtn.textContent = 'Download Color Layers';
                    downloadBtn.onclick = () => exportFile(zipBlob);
                    downloadSection.appendChild(document.createElement('br'));
                    downloadSection.appendChild(downloadBtn);
                    downloadSection.classList.add('visible');

                    progressDiv.classList.remove('loading');
                    progressDiv.innerHTML = `Done! Generated ${topCentroids.length} color layers.`;
                    processBtn.disabled = false;
                };
            } catch (err) {
                console.error('Error processing image:', err);
                progressDiv.classList.remove('loading');
                progressDiv.innerHTML = 'Error processing image';
                processBtn.disabled = false;
            }
        }
        </script>
    </div>
</body>
</html>
